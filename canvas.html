<!doctype html>

<style>
body {
  background: lightblue;
  margin: 0;
  overflow: hidden;
}
</style>

<script type="module">
import { AppCanvas } from './src/app_canvas.mjs';
import { DataSource } from './src/data_source.mjs';
import { Theme } from './src/theme.mjs';
import { Layout } from './src/layout.mjs';
import { RunLoop } from './src/run_loop.mjs';
import { Rasterizer } from './src/rasterizer.mjs';
import { DragControl } from './src/drag_control.mjs';
import { UserItem } from './src/data_sources/special_items.mjs';
import { SelectionControl } from './src/selection_control.mjs';
import { DetailsControl } from './src/details_control.mjs';

let app_canvas;
let rasterizer;
let layout;
let drag_control;
let hover_decorator;
let selection_control;
let details_control;

RunLoop.draw = () => {
  layout.layoutIfNeeded();
  app_canvas.startDraw();
  rasterizer.draw(layout.tree);
  app_canvas.endDraw();
}

async function initialize() {
  app_canvas = new AppCanvas();
  app_canvas.addEventListener("mousedown", handleMouseDown);
  app_canvas.addEventListener("mousemove", handleMouseMove);
  app_canvas.addEventListener("mousemove", handleHoverPointer);
  app_canvas.addEventListener("mouseup", handleMouseUp);
  app_canvas.addEventListener("click", handleClick);
  app_canvas.addEventListener("dblclick", handleDoubleClick);
  app_canvas.canvas.addEventListener("wheel", handleWheel);
  window.addEventListener("keyup", handleKeyUp);
  window.addEventListener("keydown", handleKeyDown);

  rasterizer = new Rasterizer(app_canvas);
  layout = new Layout(app_canvas.ctx);
  drag_control = new DragControl(layout);

  details_control = new DetailsControl();

  hover_decorator = null;
  selection_control = new SelectionControl(layout, details_control);

  const url = new URL(window.location);
  const data_source_type = url.searchParams.get("source") || "empty";
  const repo = url.searchParams.get("repo") || "vmpstr/canvasmap";

  const data_source = DataSource.Create(data_source_type, { repo: repo });
  await data_source.load();
  let y = 0;
  for (let i = 0; i < data_source.data.length; ++i) {
    const item = layout.addItem(data_source.data[i], [0, y]);
    const bounding_box = item.bounding_box;
    item.position = [-bounding_box.left, y];
    y += bounding_box.height + 2;
  }
  layout.layout();
}

function handleMouseDown(p) {
  app_canvas.finishEdit();
  return drag_control.handleMouseDown(p);
}

function handleMouseUp() {
  return drag_control.handleMouseUp();
}

function handleMouseMove(p, delta) {
  return drag_control.handleMouseMove(p, delta);
}

function handleHoverPointer(p) {
  if (app_canvas.dragging) {
    hover_decorator = null;
    selection_control.cancel();
    return;
  }
  selection_control.handleMouseMove(p);
  const decorator = layout.getDecoratorAtPoint(p);
  if (decorator && decorator.handleClick) {
    hover_decorator = decorator;
    app_canvas.canvas.style.cursor = "pointer";
  } else {
    app_canvas.canvas.style.cursor = "default";
    hover_decorator = null;
  }
}

function handleClick(p) {
  if (hover_decorator) {
    hover_decorator.handleClick();
  } else {
    selection_control.handleClick(p);
  }
}

function handleDoubleClick(p) {
  
  const item = layout.getItemAtPoint(p);
  let editing_item;
  if (item) {
    editing_item = item;
  } else {
    editing_item = layout.addItem(
      new UserItem(),
      [p[0] - Theme.padding(), p[1] - Theme.padding()]);
  }
  selection_control.selected = editing_item;
  app_canvas.startEdit(editing_item);
  return true;
}

function handleKeyDown(e) {
  if (e.key == "Tab") {
    e.preventDefault();
    e.stopPropagation();
  }
}

function handleKeyUp(e) {
  const selected = selection_control.selected;
  if (!selected)
    return;

  let need_draw = false;
  if (e.key == "Enter") {
    const editing_item = layout.addItem(new UserItem(), [0, 0]);
    if (selected.parent) {
      layout.insertChild(selected.parent, selected, editing_item);
    } else {
      layout.appendChild(selected, editing_item);
    }
    layout.layoutIfNeeded();
    app_canvas.startEdit(editing_item);
    selection_control.selected = editing_item;
    need_draw = true;
  } else if (e.key == "Tab") {
    const editing_item = layout.addItem(new UserItem(), [0, 0]);
    layout.appendChild(selected, editing_item);
    layout.layoutIfNeeded();
    app_canvas.startEdit(editing_item);
    selection_control.selected = editing_item;
    need_draw = true;
  } else if (e.key == "ArrowLeft") {
    selection_control.selectParent();
  } else if (e.key == "ArrowRight") {
    selection_control.selectChild();
  } else if (e.key == "ArrowUp") {
    selection_control.selectPreviousSibling();
  } else if (e.key == "ArrowDown") {
    selection_control.selectNextSibling();
  }

  if (need_draw)
    RunLoop.postTaskAndDraw();
}

function handleWheel(e) {
  e.preventDefault();
  e.stopPropagation();
  if (e.ctrlKey) {
    if (e.wheelDelta < 0) {
      app_canvas.zoom = Math.max(0.5, app_canvas.zoom - 0.1);
    } else {
      app_canvas.zoom = Math.min(2, app_canvas.zoom + 0.1);
    }
    RunLoop.postTaskAndDraw();
  }
}

onload = () => {
  requestAnimationFrame(() => {
    initialize().then(() => RunLoop.postTaskAndDraw());
  });
}

</script>
